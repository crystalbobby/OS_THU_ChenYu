# 3 OS如何管理物理内存
+ 计算机体系结构及内存分层体系
+ 地址空间和地址生成
+ 连续内存分配

# 3.1 计算机体系结构及内存分层体系
+ 计算机体系结构
  - CPU
  - Memory
  - I/O
  ![](../Resources/3-hardware.png)
+ 内存分层体系: cpu要访问的指令或者数据所处的位置
  - 寄存器/cache: 
    + OS无法直接管理
    + 速度快
    + 容量小
  - 主存/物理内存
    + 容量大很多
    + 速度相对慢
  - 硬盘
    + 永久保存数据
    + 容量大
    + 速度慢
  - 容量和速度似乎鱼和熊掌不可兼得， 但在OS 帮助之下， 可以完成近乎不可能完成的任务。(4个目标)
    + 抽象
    + 保护
    + 共享
    + 虚拟化
    ![](../Resources/3-osmemory.png)
  - OS管理内存的不同方法
    + 程序重定位
    + 分段
    + 分页
    + 虚拟内存
    + 按需分页虚拟内存
  - 实现高度依赖于硬件
    + 必须知道内存架构
    + MMU：内存管理单元，硬件组件负责处理CPU的内存访问请求

+ 在OS的内存管理范例

# 3.2 地址空间与地址生成
+ 地址空间的定义
+ 地址生成
+ 地址安全检查（各个进程不相互干扰）
## 地址空间
+ 物理地址空间
  - 硬件支持的地址空间
    + 主存
    + 硬盘
  - 起始地址 0， 到地址 MAX_sys
+ 逻辑地址空间
  - 一个运行程序所拥有的内存范围
  - 起始地址 0， 到MAX_prog
  
  ![](../Resources/3-addressspace.png)
+ 映射关系由OS决定  
+ 逻辑地址生成： 符号逻辑地址到内存中实际逻辑地址
  - .c file: 变量名，函数位置即地址
  - .s file: 汇编语言仍然使用变量名为地址
  - .o file: 机器语言起始地址为0， 变量函数符号等转换为相应的从零开始的地址
  - .exe file: 不同的 .o 程序变为单一执行程序，不同.o程序中的地址做全局分布
  - 内存中的程序: 使用loader将exeload到内存中，加上一个偏移量，仍为逻辑地址
 
  ![](../Resources/3-logicaddressgeneration.png)
+ 物理地址生成：
  - CPU 方面：
    + 运算器ALU需要在逻辑地址的内存内容，发出请求，参数为逻辑地址
    + 内存管理单元寻找在逻辑地址和物理地址之间的映射，MMU中没有就去内存中去找（图中蓝色部分，cpu蓝色部分为映射缓存，存储了LA->PA的映射关系）
    + 控制器从总线发送在物理地址的内容的请求
  - 内存方面
    + 内存发送物理地址内存的内容给cpu
  - OS方面
    + 建立逻辑地址和物理地址的映射
    + 对地址空间的
    

![](../Resources/3-physicaladdressgeneration.png)

+ 
